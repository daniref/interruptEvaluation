; --------------------------------------------------------------------------------
; @Title: Load the Bitstream of an UltraScale+ PL via the CSU
; @Description:
;   This script loads a .bit or bit.bin file generated by the Xilinx Toolchain
;   into the PL/FPGA using the CSU.
;   Usage:
;     DO zynq-ultrascale_load_bitstream <file> <address_in_ram>
; @Board: ZCU102
; @Chip: ZYNQ-ULTRASCALE+*
; @Author: MPL
; @Copyright: (C) 1989-2019 Lauterbach GmbH, licensed for use with TRACE32(R) only
; $Id: zynq-ultrascale_load_bitstream.cmm 15099 2019-10-16 09:51:55Z amerkle $
; --------------------------------------------------------------------------------

PRIVATE &csu_base &pmu_base &dma_base
PRIVATE &file &addr &params
PRIVATE &stream_length
ENTRY %LINE &params

IF CPU.FEATURE(SECURE)
(
  &csu_base=AZD:0xFFCA0000
  &pmu_base=AZD:0xFFD80000
  &dma_base=AZD:0xFFC80000
)
ELSE
(
  &csu_base=AD:0xFFCA0000
  &pmu_base=AD:0xFFD80000
  &dma_base=AD:0xFFC80000
)

GOSUB ParseParameters &params
RETURNVALUES &file &addr &stream_length

IF STATE.RUN()
(
  Break.direct
)

IF "&file"=="/RAM"
(
  &stream_length=(&stream_length+0x3)&~0x3

  IF &stream_length<=0.
  (
    PRINT %ERROR "Invalid SIZE=<> argument!"
    ENDDO FALSE()
  )
)
ELSE
(
  GOSUB LoadBitfile "&file" "&addr"
  RETURNVALUES &stream_length

  IF &stream_length<0.
  (
    ; error already printed by load_bitfile
    ENDDO FALSE()
  )
)

; Initialize PCAP Interface
Data.Set &csu_base+0x300C %Long %LE 0x0              ; CSU.pcap_reset.reset          = 0
Data.Set &csu_base+0x3008 %Long %LE 0x1              ; CSU.pcap_ctrl.pcap_pr         = 1

; Power up PL through PMU
Data.Set &pmu_base+0x0118 %Long %LE 1.<<23.          ; PMU.req_pwrup_int_en.pl       = 1
Data.Set &pmu_base+0x0120 %Long %LE 1.<<23.          ; PMU.req_pwrup_trig.pl         = 1

; Request PL isolation for non-PCAP signals through the PMU
Data.Set &pmu_base+0x0318 %Long %LE 1.<<2.           ; PMU.req_iso_int_en.pl_nonpcap = 1
Data.Set &pmu_base+0x0320 %Long %LE 1.<<2.           ; PMU.req_iso_trig.pl_nonpcap   = 1

; Pulse PL reset
Data.Set &csu_base+0x3000 %Long %LE 0x0              ; CSU.pcap_prog.pcfg_prog_b     = 0
WAIT 1ms
Data.Set &csu_base+0x3000 %Long %LE 0x1              ; CSU.pcap_prog.pcfg_prog_b     = 1

; poll until CSU.pcap_status.pl_init == 1
WAIT (Data.Long(&csu_base+0x3010)&(1.<<2.))!=0x0 5.s
IF (Data.Long(&csu_base+0x3010)&(1.<<2.))==0x0
(
  PRINT %ERROR "PL initialisation timed out"
  ENDDO FALSE()
)

; set up CSUDMA to do the transfer
Data.Set &csu_base+0x0008 %Long %LE 0x5              ; CSU.csu_sss_cfg.pcap_sss      = 0x5 (DMA)
Data.Set &dma_base+0x0000 %Long %LE &addr&0xFFFFFFFF ; CSUDMA.csudma_src_addr
Data.Set &dma_base+0x0028 %Long %LE &addr>>32.       ; CSUDMA.csudma_src_addr_msb
Data.Set &dma_base+0x0004 %Long %LE &stream_length   ; CSUDMA.csudma_src_size

; poll until CSUDMA.csudma_src_sts.busy == 0
WAIT (Data.Long(&dma_base+0x0008)&(1.<<0.))==0x0 5.s
IF (Data.Long(&dma_base+0x0008)&(1.<<0.))!=0x0
(
  PRINT %ERROR "Error - DMA transfer timed out"
  ENDDO FALSE()
)

; acknowledge completed DMA transfers
Data.Set &dma_base+0x0008 %Long %LE 0x7<<13.         ; CSUDMA.csudma_src_sts.cnt     = 0y111

; poll until CSU.pcap_status.pcap_wr_idle == 1
WAIT (Data.Long(&csu_base+0x3010)&(1.<<0.))!=0x0 5.s
IF (Data.Long(&csu_base+0x3010)&(1.<<0.))==0x0
(
  PRINT %ERROR "PL programming timed out"
  ENDDO FALSE()
)

; reset PCAP
Data.Set &csu_base+0x300C %Long %LE 0x1              ; CSU.pcap_reset.reset          = 1

; remove PL isolation: request a power-up through the PMU
Data.Set &pmu_base+0x0118 %Long %LE 1.<<23.          ; PMU.req_pwrup_int_en.pl       = 1
Data.Set &pmu_base+0x0120 %Long %LE 1.<<23.          ; PMU.req_pwrup_trig.pl         = 1

PRINT "PL programmed!"

ENDDO TRUE()

; --------------------------------------------------------------------------------
; Subroutines

ParseParameters: ;(params)
(
  PRIVATE &params &file &ram_start &size
  ENTRY &file %LINE &params
  &file=STRing.Replace("&file","""","",0.)
  &ram_start=STRing.SCANAndExtract("&params","0x","")
  &size=STRing.SCANAndExtract("&params","SIZE=0x","0")
  IF (("&file"!="/RAM")&&!OS.FILE("&file"))||"&ram_start"==""
  (
    GOSUB PrintUsage
    ENDDO FALSE()
  )

  &ram_start="0x&ram_start"
  &size="0x&size"
  IF (&ram_start&0x3)!=0x0
  (
    PRINT %ERROR "Address must be aligned to 32-bit boundary"
    ENDDO FALSE()
  )

  RETURN "&file" "&ram_start" "&size"
)

; load Xilinx .bit or .bin file to given address
; returns length of the file or -1 on error
LoadBitfile: ;(file address)
(
  PRIVATE &filename &addr &file_size &stream_offset &stream_length
  PARAMETERS &filename &addr


  IF !OS.FILE("&filename")
  (
    PRINT %ERROR "File &filename does not exist"
    ENDDO FALSE()
  )

  &file_size=OS.FILE.SIZE("&filename")

  ; search for the magic pattern at the start of the bitstream.
  ; in a .bin file, this should be at offset zero.
  ; in a .bit file, there is a header containing some ASCII strings, which we must skip.
  Data.LOAD.Binary "&filename" AVM:0x0 /NosYmbol
  PRIVATE &x &isBit &isBitBin
  &x="0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF"

  Data.Find AVM:0x0++(&file_size-0x1) %Byte &x &x &x &x &x &x &x &x 0x00 0x00 0x00 0xBB 0x11 0x22 0x00 0x44 &x 0xAA 0x99 0x55 0x66
  &isBit=FOUND()
  Data.Find AVM:0x0++(&file_size-0x1) %Byte &x &x &x &x &x &x &x &x 0xBB 0x00 0x00 0x00 0x44 0x00 0x22 0x11 &x 0x66 0x55 0x99 0xaa
  &isBitBin=FOUND()

  IF !(&isBit||&isBitBin)
  (
    PRINT %ERROR "Sync pattern not found - is this a .bit or .bin file?"
    ENDDO FALSE()
  )

  ; calculate bitstream offset (can be unaligned) and length, rounded up to a multiple of 4 bytes
  &stream_offset=ADDRESS.OFFSET(TRACK.ADDRESS())
  &stream_length=(&file_size-&stream_offset+0x3)&~0x3
  PRINT "stream starts at &stream_offset, length &stream_length"

  ; if it's a bitstream load bitstream into RAM and swap (the FPGA expects big endian words)
  IF &isBit
  (
    Data.LOAD.Binary "&filename" AVM:0x0 /NosYmbol /LongSWAP /SKIP &stream_offset
  )
  Data.COPY AVM:0x0++&stream_length AD:&addr
  CACHE.FLUSH.DC
  IF PRACTICE.CoMmanD.AVAILable(CACHE.FLUSH.L2)
  (
    CACHE.FLUSH.L2
  )

  RETURN "&stream_length"
)

PrintUsage: ;()
(
  PRINT "Usage:"
  PRINT "    DO zynq-ultrascale_load_bitstream.cmm ""/path/to/bitfile.bit"" <address>"
  PRINT "    DO zynq-ultrascale_load_bitstream.cmm ""/path/to/bitfile.bin"" <address>"
  PRINT "    DO zynq-ultrascale_load_bitstream.cmm /RAM <address> <length>"
  PRINT ""
  PRINT "The first two versions load the bitfile to the given address and then load"
  PRINT "the FPGA. Previous memory contents are not preserved."
  PRINT "The final version only loads the FPGA with data already in RAM."
  PRINT ""
  PRINT "Example:"
  PRINT "    ; load bitstream for the first time"
  PRINT "    DO zynq-ultrascale_load_bitstream.cmm ""design_1_wrapper.bit"" 0x10000000"
  PRINT ""
  PRINT "    ; re-load the same bitstream at a later time"
  PRINT "    DO ultrascaleplus_bitstream.cmm /RAM 0x10000000 SIZE=<size>"
  PRINT ""
  PRINT %ERROR "Invalid Usage! Type AREA for more details."
  ENDDO FALSE()
)
